# ğŸ›¡ï¸ AIæ˜ä¿¡ç‰‡ç³»ç»Ÿå®‰å…¨æ¼æ´ä¿®å¤ä¸ä¼˜åŒ–å‡çº§æ–¹æ¡ˆ

> **æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
> **åˆ›å»ºæ—¥æœŸ**: 2025-09-08  
> **ä½œè€…**: Claude Code Assistant  
> **æ–‡æ¡£ç±»å‹**: å®‰å…¨æ¶æ„è®¾è®¡æ–¹æ¡ˆ  

## ğŸ“‹ æ–‡æ¡£æ¦‚è§ˆ

### **ğŸ¯ å‡çº§ç›®æ ‡**
- **é›¶ä¿¡ä»»å®‰å…¨æ¶æ„**: æ‰€æœ‰APIè°ƒç”¨å¿…é¡»ç»è¿‡èº«ä»½éªŒè¯å’Œæƒé™éªŒè¯
- **å¹¶å‘å®‰å…¨ä¿éšœ**: æ¶ˆé™¤ç«æ€æ¡ä»¶ï¼Œç¡®ä¿é…é¢é™åˆ¶ä¸¥æ ¼æ‰§è¡Œ
- **æ•°æ®å®‰å…¨é˜²æŠ¤**: ç”¨æˆ·èµ„æºè®¿é—®éš”ç¦»ï¼Œé˜²æ­¢è¶Šæƒæ“ä½œ
- **å®æ—¶ç›‘æ§é¢„è­¦**: å»ºç«‹å®Œå–„çš„å®‰å…¨å®¡è®¡å’Œå¼‚å¸¸æ£€æµ‹ä½“ç³»

### **ğŸš¨ å‘ç°çš„å®‰å…¨æ¼æ´**
é€šè¿‡å…¨é¢çš„å®‰å…¨å®¡æŸ¥ï¼Œå‘ç°äº†**5ä¸ªä¸¥é‡çš„å®‰å…¨æ¼æ´**ï¼š

1. **ç”¨æˆ·èº«ä»½éªŒè¯å®Œå…¨ç¼ºå¤±** (CRITICAL) - ä»»ä½•äººå¯ä»¥å†’å……ä»»æ„ç”¨æˆ·
2. **å¹¶å‘ç«æ€æ¡ä»¶ç»•è¿‡é…é¢é™åˆ¶** (HIGH) - å¤šè¯·æ±‚å¯ç»•è¿‡æ¯æ—¥2æ¬¡é™åˆ¶
3. **åˆ é™¤APIç¼ºå°‘æƒé™éªŒè¯** (CRITICAL) - ä»»ä½•äººéƒ½å¯ä»¥åˆ é™¤ä»»æ„ç”¨æˆ·æ˜ä¿¡ç‰‡
4. **é…é¢æŸ¥è¯¢APIä¿¡æ¯æ³„éœ²** (MEDIUM) - å¯æŸ¥è¯¢ä»»æ„ç”¨æˆ·é…é¢çŠ¶æ€
5. **å‰ç«¯é…é¢æ£€æŸ¥å¯è¢«ç»•è¿‡** (LOW) - ç›´æ¥è°ƒç”¨APIç»•è¿‡å‰ç«¯æ£€æŸ¥

---

## ğŸ” ç¬¬ä¸€é˜¶æ®µï¼šèº«ä»½éªŒè¯æ¶æ„è®¾è®¡

### **ğŸ”‘ JWTèº«ä»½éªŒè¯ä½“ç³»è®¾è®¡**

#### **1.1 Tokenæ¶æ„è®¾è®¡**
```python
# ğŸ”¥ JWT Tokenç»“æ„è®¾è®¡
class TokenPayload(BaseModel):
    user_id: str           # ç”¨æˆ·å”¯ä¸€æ ‡è¯†
    openid: str           # å¾®ä¿¡ç”¨æˆ·openid
    role: str = "user"    # ç”¨æˆ·è§’è‰²
    permissions: List[str] # æƒé™åˆ—è¡¨
    exp: int              # è¿‡æœŸæ—¶é—´æˆ³
    iat: int              # ç­¾å‘æ—¶é—´æˆ³
    jti: str              # Tokenå”¯ä¸€æ ‡è¯†ï¼ˆç”¨äºæ’¤é”€ï¼‰
    
# ğŸ”¥ Tokenç”Ÿæˆå’ŒéªŒè¯æœåŠ¡
class AuthService:
    def __init__(self):
        self.secret_key = os.getenv("JWT_SECRET_KEY")
        self.algorithm = "HS256"
        self.access_token_expire = 7 * 24 * 3600  # 7å¤©
        
    async def create_access_token(self, user_data: dict) -> str:
        """åˆ›å»ºè®¿é—®ä»¤ç‰Œ"""
        now = datetime.utcnow()
        payload = {
            "user_id": user_data["id"],
            "openid": user_data["openid"],
            "role": user_data.get("role", "user"),
            "permissions": self._get_user_permissions(user_data["role"]),
            "exp": now + timedelta(seconds=self.access_token_expire),
            "iat": now,
            "jti": str(uuid.uuid4())
        }
        
        # ç¼“å­˜Tokenç”¨äºæ’¤é”€æ§åˆ¶
        await self._cache_token(payload["jti"], payload["user_id"])
        
        return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)
```

#### **1.2 èº«ä»½éªŒè¯ä¸­é—´ä»¶**
```python
# ğŸ”¥ å…¨å±€èº«ä»½éªŒè¯ä¸­é—´ä»¶
class AuthenticationMiddleware:
    def __init__(self, app):
        self.app = app
        self.auth_service = AuthService()
        self.excluded_paths = ["/health", "/docs", "/openapi.json"]
        
    async def __call__(self, scope, receive, send):
        request = Request(scope, receive)
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºæ’é™¤è·¯å¾„
        if request.url.path in self.excluded_paths:
            return await self.app(scope, receive, send)
            
        try:
            # æå–Token
            token = self._extract_token(request)
            if not token:
                raise AuthenticationError("ç¼ºå°‘èº«ä»½éªŒè¯ä»¤ç‰Œ")
                
            # éªŒè¯Token
            payload = await self.auth_service.verify_token(token)
            
            # æ£€æŸ¥Tokenæ˜¯å¦è¢«æ’¤é”€
            if await self.auth_service.is_token_revoked(payload["jti"]):
                raise AuthenticationError("ä»¤ç‰Œå·²å¤±æ•ˆ")
                
            # å°†ç”¨æˆ·ä¿¡æ¯æ³¨å…¥è¯·æ±‚ä¸Šä¸‹æ–‡
            request.state.user = CurrentUser(
                user_id=payload["user_id"],
                openid=payload["openid"],
                role=payload["role"],
                permissions=set(payload["permissions"])
            )
            
            return await self.app(scope, receive, send)
            
        except AuthenticationError as e:
            response = JSONResponse(
                status_code=401,
                content={"code": -401, "message": f"èº«ä»½éªŒè¯å¤±è´¥: {str(e)}"}
            )
            return await response(scope, receive, send)
```

#### **1.3 å¾®ä¿¡å°ç¨‹åºç™»å½•æµç¨‹é‡æ„**
```python
# ğŸ”¥ å®‰å…¨ç™»å½•æµç¨‹
@router.post("/auth/miniprogram/login")
async def miniprogram_login(
    request: MiniprogramLoginRequest,
    db: Session = Depends(get_db)
):
    """å¾®ä¿¡å°ç¨‹åºå®‰å…¨ç™»å½•"""
    try:
        # 1. éªŒè¯å¾®ä¿¡code
        wx_session = await WeChatService.code_to_session(request.code)
        if not wx_session.get("openid"):
            raise AuthenticationError("å¾®ä¿¡æˆæƒéªŒè¯å¤±è´¥")
            
        # 2. è·å–æˆ–åˆ›å»ºç”¨æˆ·
        user_service = UserService(db)
        user = await user_service.get_or_create_user(
            openid=wx_session["openid"],
            user_info=request.user_info
        )
        
        # 3. ç”Ÿæˆå®‰å…¨Token
        auth_service = AuthService()
        access_token = await auth_service.create_access_token(user.__dict__)
        refresh_token = await auth_service.create_refresh_token(user.id)
        
        # 4. è®°å½•ç™»å½•æ—¥å¿—
        await AuditService.log_user_action(
            user_id=user.id,
            action="LOGIN",
            details={"client_type": "miniprogram", "ip": request.client.host}
        )
        
        return {
            "code": 0,
            "message": "ç™»å½•æˆåŠŸ",
            "data": {
                "access_token": access_token,
                "refresh_token": refresh_token,
                "expires_in": 7 * 24 * 3600,
                "user": user.to_dict()
            }
        }
        
    except Exception as e:
        logger.error(f"å°ç¨‹åºç™»å½•å¤±è´¥: {str(e)}")
        raise HTTPException(status_code=400, detail="ç™»å½•å¤±è´¥")
```

---

## ğŸ›¡ï¸ ç¬¬äºŒé˜¶æ®µï¼šæƒé™æ§åˆ¶ä½“ç³»è®¾è®¡

### **ğŸ­ RBACæƒé™æ¨¡å‹è®¾è®¡**

#### **2.1 æƒé™æ¨¡å‹æ•°æ®ç»“æ„**
```sql
-- ğŸ”¥ æƒé™ç³»ç»Ÿæ•°æ®åº“è®¾è®¡
CREATE TABLE user_roles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id),
    role_name VARCHAR(50) NOT NULL,
    granted_by UUID REFERENCES users(id),
    granted_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP NULL,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,        -- postcard:create, postcard:delete
    resource VARCHAR(50) NOT NULL,            -- postcard, user, quota
    action VARCHAR(50) NOT NULL,              -- create, read, update, delete
    description TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE role_permissions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    role_name VARCHAR(50) NOT NULL,
    permission_id UUID NOT NULL REFERENCES permissions(id),
    created_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(role_name, permission_id)
);

-- ğŸ”¥ èµ„æºæ‰€æœ‰æƒè¡¨
CREATE TABLE resource_ownership (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    resource_type VARCHAR(50) NOT NULL,       -- postcard, quota
    resource_id VARCHAR(255) NOT NULL,        -- èµ„æºID
    owner_id UUID NOT NULL REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(resource_type, resource_id)
);
```

#### **2.2 æƒé™éªŒè¯è£…é¥°å™¨**
```python
# ğŸ”¥ æƒé™éªŒè¯è£…é¥°å™¨
def require_permission(permission: str, resource_check: bool = False):
    """
    æƒé™éªŒè¯è£…é¥°å™¨
    
    Args:
        permission: éœ€è¦çš„æƒé™ï¼Œå¦‚ "postcard:create", "postcard:delete"
        resource_check: æ˜¯å¦éœ€è¦æ£€æŸ¥èµ„æºæ‰€æœ‰æƒ
    """
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            # è·å–å½“å‰ç”¨æˆ·ï¼ˆç”±èº«ä»½éªŒè¯ä¸­é—´ä»¶æ³¨å…¥ï¼‰
            request = args[0] if args else kwargs.get('request')
            if not hasattr(request.state, 'user'):
                raise PermissionError("ç”¨æˆ·èº«ä»½éªŒè¯å¤±è´¥")
                
            current_user = request.state.user
            
            # æ£€æŸ¥åŸºç¡€æƒé™
            if permission not in current_user.permissions:
                raise PermissionError(f"ç¼ºå°‘æƒé™: {permission}")
                
            # æ£€æŸ¥èµ„æºæ‰€æœ‰æƒï¼ˆå¦‚æœéœ€è¦ï¼‰
            if resource_check:
                resource_id = kwargs.get('postcard_id') or kwargs.get('resource_id')
                if not resource_id:
                    raise PermissionError("ç¼ºå°‘èµ„æºæ ‡è¯†")
                    
                ownership_service = ResourceOwnershipService()
                resource_type = permission.split(':')[0]  # postcard:delete -> postcard
                
                if not await ownership_service.check_ownership(
                    resource_type=resource_type,
                    resource_id=resource_id,
                    user_id=current_user.user_id
                ):
                    raise PermissionError("æ— æƒè®¿é—®è¯¥èµ„æº")
                    
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# ğŸ”¥ èµ„æºæ‰€æœ‰æƒæœåŠ¡
class ResourceOwnershipService:
    def __init__(self, db: Session):
        self.db = db
        
    async def register_ownership(self, resource_type: str, resource_id: str, owner_id: str):
        """æ³¨å†Œèµ„æºæ‰€æœ‰æƒ"""
        ownership = ResourceOwnership(
            resource_type=resource_type,
            resource_id=resource_id,
            owner_id=owner_id
        )
        self.db.add(ownership)
        self.db.commit()
        
    async def check_ownership(self, resource_type: str, resource_id: str, user_id: str) -> bool:
        """æ£€æŸ¥èµ„æºæ‰€æœ‰æƒ"""
        ownership = self.db.query(ResourceOwnership).filter(
            ResourceOwnership.resource_type == resource_type,
            ResourceOwnership.resource_id == resource_id,
            ResourceOwnership.owner_id == user_id
        ).first()
        
        return ownership is not None
        
    async def transfer_ownership(self, resource_type: str, resource_id: str, new_owner_id: str):
        """è½¬ç§»èµ„æºæ‰€æœ‰æƒ"""
        ownership = self.db.query(ResourceOwnership).filter(
            ResourceOwnership.resource_type == resource_type,
            ResourceOwnership.resource_id == resource_id
        ).first()
        
        if ownership:
            ownership.owner_id = new_owner_id
            ownership.updated_at = datetime.utcnow()
            self.db.commit()
```

#### **2.3 å®‰å…¨APIç«¯ç‚¹é‡æ„**
```python
# ğŸ”¥ å®‰å…¨çš„æ˜ä¿¡ç‰‡åˆ›å»ºAPI
@router.post("/postcards/create")
@require_permission("postcard:create")
async def create_miniprogram_postcard(
    request: PostcardRequest,
    current_user: CurrentUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """å°ç¨‹åºï¼šåˆ›å»ºæ˜ä¿¡ç‰‡ç”Ÿæˆä»»åŠ¡ï¼ˆå®‰å…¨ç‰ˆæœ¬ï¼‰"""
    try:
        # ğŸ”¥ å¼ºåˆ¶ä½¿ç”¨å½“å‰ç”¨æˆ·IDï¼Œé˜²æ­¢ä¼ªé€ 
        request.user_id = current_user.user_id
        
        logger.info(f"ç”¨æˆ· {current_user.user_id} åˆ›å»ºæ˜ä¿¡ç‰‡ä»»åŠ¡")
        
        service = PostcardService(db)
        task_id = await service.create_task(request)
        
        # ğŸ”¥ æ³¨å†Œèµ„æºæ‰€æœ‰æƒ
        ownership_service = ResourceOwnershipService(db)
        postcard = await service.get_postcard_by_task_id(task_id)
        await ownership_service.register_ownership(
            resource_type="postcard",
            resource_id=postcard.id,
            owner_id=current_user.user_id
        )
        
        # è®°å½•æ“ä½œæ—¥å¿—
        await AuditService.log_user_action(
            user_id=current_user.user_id,
            action="POSTCARD_CREATE",
            resource_id=task_id,
            details={"user_input": request.user_input[:100]}
        )
        
        return {
            "code": 0,
            "message": "ä»»åŠ¡åˆ›å»ºæˆåŠŸ",
            "data": {
                "task_id": task_id,
                "status": TaskStatus.PENDING.value,
                "estimated_time": "2-3åˆ†é’Ÿ"
            }
        }
        
    except PermissionError as e:
        logger.warning(f"æƒé™éªŒè¯å¤±è´¥: {current_user.user_id} - {str(e)}")
        return {"code": -403, "message": f"æƒé™ä¸è¶³: {str(e)}"}
    except Exception as e:
        logger.error(f"åˆ›å»ºä»»åŠ¡å¤±è´¥: {str(e)}")
        return {"code": -1, "message": f"åˆ›å»ºå¤±è´¥: {str(e)}"}

# ğŸ”¥ å®‰å…¨çš„æ˜ä¿¡ç‰‡åˆ é™¤API
@router.delete("/postcards/{postcard_id}")
@require_permission("postcard:delete", resource_check=True)
async def delete_miniprogram_postcard(
    postcard_id: str,
    current_user: CurrentUser = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """å°ç¨‹åºï¼šåˆ é™¤æ˜ä¿¡ç‰‡ï¼ˆå®‰å…¨ç‰ˆæœ¬ï¼‰"""
    try:
        service = PostcardService(db)
        
        # éªŒè¯æ˜ä¿¡ç‰‡å­˜åœ¨ä¸”å±äºå½“å‰ç”¨æˆ·
        postcard = await service.get_postcard_by_id(postcard_id)
        if not postcard:
            return {"code": -1, "message": "æ˜ä¿¡ç‰‡ä¸å­˜åœ¨"}
            
        if postcard.user_id != current_user.user_id:
            return {"code": -403, "message": "æ— æƒåˆ é™¤è¯¥æ˜ä¿¡ç‰‡"}
            
        # æ‰§è¡Œåˆ é™¤
        success = await service.delete_postcard(postcard_id)
        
        if success:
            # è®°å½•åˆ é™¤æ—¥å¿—
            await AuditService.log_user_action(
                user_id=current_user.user_id,
                action="POSTCARD_DELETE",
                resource_id=postcard_id,
                details={"title": postcard.content.get("title", "")[:50]}
            )
            
            return {"code": 0, "message": "åˆ é™¤æˆåŠŸ"}
        else:
            return {"code": -1, "message": "åˆ é™¤å¤±è´¥"}
            
    except Exception as e:
        logger.error(f"åˆ é™¤å¤±è´¥: {str(e)}")
        return {"code": -1, "message": f"åˆ é™¤å¤±è´¥: {str(e)}"}
```

---

## âš¡ ç¬¬ä¸‰é˜¶æ®µï¼šå¹¶å‘æ§åˆ¶æœºåˆ¶è®¾è®¡

### **ğŸ”’ å¹¶å‘å®‰å…¨é…é¢ç³»ç»Ÿé‡æ„**

#### **3.1 æ•°æ®åº“å±‚å¹¶å‘æ§åˆ¶**
```sql
-- ğŸ”¥ ä¼˜åŒ–åçš„é…é¢è¡¨è®¾è®¡ï¼ˆæ·»åŠ ç‰ˆæœ¬æ§åˆ¶ï¼‰
ALTER TABLE user_quotas ADD COLUMN version INTEGER DEFAULT 1;
ALTER TABLE user_quotas ADD COLUMN locked_at TIMESTAMP NULL;
ALTER TABLE user_quotas ADD COLUMN locked_by VARCHAR(255) NULL;

-- ğŸ”¥ åˆ›å»ºå¤åˆç´¢å¼•ä¼˜åŒ–å¹¶å‘æ€§èƒ½
CREATE INDEX CONCURRENTLY idx_user_quotas_lock 
ON user_quotas (user_id, quota_date, version) 
WHERE locked_at IS NULL;

-- ğŸ”¥ é…é¢åˆ†å¸ƒå¼é”è¡¨
CREATE TABLE quota_locks (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL,
    quota_date DATE NOT NULL,
    lock_id VARCHAR(255) UNIQUE NOT NULL,
    locked_at TIMESTAMP DEFAULT NOW(),
    expires_at TIMESTAMP NOT NULL,
    locked_by VARCHAR(255) NOT NULL,  -- æœåŠ¡å®ä¾‹ID
    operation VARCHAR(50) NOT NULL,   -- CREATE, DELETE, UPDATE
    UNIQUE(user_id, quota_date, operation)
);
```

#### **3.2 åˆ†å¸ƒå¼é”æœåŠ¡**
```python
# ğŸ”¥ Redisåˆ†å¸ƒå¼é”å®ç°
class DistributedLockService:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.lock_timeout = 30  # 30ç§’è¶…æ—¶
        self.instance_id = f"{socket.gethostname()}_{os.getpid()}"
        
    async def acquire_quota_lock(self, user_id: str, operation: str) -> Optional[str]:
        """è·å–é…é¢æ“ä½œåˆ†å¸ƒå¼é”"""
        lock_key = f"quota_lock:{user_id}:{operation}"
        lock_value = f"{self.instance_id}:{int(time.time())}"
        
        # ä½¿ç”¨SETå‘½ä»¤çš„NXå’ŒEXå‚æ•°å®ç°åŸå­é”
        acquired = await self.redis.set(
            lock_key, 
            lock_value, 
            ex=self.lock_timeout,
            nx=True
        )
        
        if acquired:
            logger.debug(f"è·å¾—é…é¢é”: {lock_key} by {self.instance_id}")
            return lock_value
        else:
            logger.warning(f"é…é¢é”è·å–å¤±è´¥: {lock_key}")
            return None
            
    async def release_quota_lock(self, user_id: str, operation: str, lock_value: str):
        """é‡Šæ”¾é…é¢æ“ä½œåˆ†å¸ƒå¼é”"""
        lock_key = f"quota_lock:{user_id}:{operation}"
        
        # ä½¿ç”¨Luaè„šæœ¬ç¡®ä¿åŸå­é‡Šæ”¾
        lua_script = """
        if redis.call("GET", KEYS[1]) == ARGV[1] then
            return redis.call("DEL", KEYS[1])
        else
            return 0
        end
        """
        
        result = await self.redis.eval(lua_script, 1, lock_key, lock_value)
        if result:
            logger.debug(f"é‡Šæ”¾é…é¢é”: {lock_key}")
        else:
            logger.warning(f"é…é¢é”é‡Šæ”¾å¤±è´¥: {lock_key} - å¯èƒ½å·²è¿‡æœŸ")
```

#### **3.3 å¹¶å‘å®‰å…¨çš„é…é¢æœåŠ¡é‡æ„**
```python
# ğŸ”¥ å¹¶å‘å®‰å…¨çš„é…é¢æœåŠ¡
class ConcurrentSafeQuotaService:
    def __init__(self, db: Session, redis_client):
        self.db = db
        self.lock_service = DistributedLockService(redis_client)
        self.max_retry = 3
        self.retry_delay = 0.1  # 100ms
        
    async def consume_generation_quota_safe(self, user_id: str, card_id: str) -> bool:
        """å¹¶å‘å®‰å…¨çš„é…é¢æ¶ˆè´¹"""
        lock_value = None
        try:
            # ğŸ”¥ 1. è·å–åˆ†å¸ƒå¼é”
            for attempt in range(self.max_retry):
                lock_value = await self.lock_service.acquire_quota_lock(user_id, "CREATE")
                if lock_value:
                    break
                    
                if attempt < self.max_retry - 1:
                    await asyncio.sleep(self.retry_delay * (2 ** attempt))  # æŒ‡æ•°é€€é¿
                    
            if not lock_value:
                raise QuotaLockError("æ— æ³•è·å–é…é¢é”ï¼Œè¯·ç¨åé‡è¯•")
                
            # ğŸ”¥ 2. åœ¨æ•°æ®åº“äº‹åŠ¡ä¸­æ‰§è¡Œé…é¢æ£€æŸ¥å’Œæ¶ˆè´¹
            async with self.db.begin():
                # ä½¿ç”¨SELECT FOR UPDATEé˜²æ­¢è¯»å–æ—¶çš„ç«æ€æ¡ä»¶
                quota = await self._get_user_quota_with_lock(user_id)
                
                # ä¸¥æ ¼æ£€æŸ¥é…é¢
                if not quota.can_generate:
                    raise QuotaExceededException(
                        f"é…é¢ä¸è¶³: å·²ç”Ÿæˆ{quota.generated_count}æ¬¡ï¼Œ"
                        f"å½“å‰{'æœ‰' if quota.current_card_exists else 'æ— '}å¡ç‰‡"
                    )
                    
                # ğŸ”¥ ä½¿ç”¨ä¹è§‚é”æ›´æ–°é…é¢
                old_version = quota.version
                quota.generated_count += 1
                quota.current_card_exists = True
                quota.current_card_id = card_id
                quota.version += 1
                quota.updated_at = datetime.utcnow()
                
                # éªŒè¯ç‰ˆæœ¬å·ï¼Œé˜²æ­¢å¹¶å‘æ›´æ–°
                update_result = self.db.execute(
                    text("""
                    UPDATE user_quotas 
                    SET generated_count = :generated_count,
                        current_card_exists = :current_card_exists,
                        current_card_id = :current_card_id,
                        version = :new_version,
                        updated_at = :updated_at
                    WHERE user_id = :user_id 
                      AND quota_date = :quota_date 
                      AND version = :old_version
                    """),
                    {
                        "generated_count": quota.generated_count,
                        "current_card_exists": True,
                        "current_card_id": card_id,
                        "new_version": quota.version,
                        "updated_at": quota.updated_at,
                        "user_id": user_id,
                        "quota_date": quota.quota_date,
                        "old_version": old_version
                    }
                )
                
                if update_result.rowcount == 0:
                    raise ConcurrentUpdateError("é…é¢çŠ¶æ€å·²è¢«å…¶ä»–æ“ä½œæ›´æ–°ï¼Œè¯·é‡è¯•")
                    
                logger.info(f"âœ… å®‰å…¨æ¶ˆè´¹é…é¢: {user_id} - å¡ç‰‡:{card_id} - ç‰ˆæœ¬:{old_version}â†’{quota.version}")
                return True
                
        except Exception as e:
            logger.error(f"âŒ é…é¢æ¶ˆè´¹å¤±è´¥: {user_id} - {str(e)}")
            raise
        finally:
            # ğŸ”¥ 3. ç¡®ä¿é‡Šæ”¾åˆ†å¸ƒå¼é”
            if lock_value:
                await self.lock_service.release_quota_lock(user_id, "CREATE", lock_value)
                
    async def _get_user_quota_with_lock(self, user_id: str) -> UserQuota:
        """ä½¿ç”¨æ‚²è§‚é”è·å–ç”¨æˆ·é…é¢"""
        today = self._today()
        
        quota = self.db.query(UserQuota).filter(
            UserQuota.user_id == user_id,
            UserQuota.quota_date == today
        ).with_for_update().first()  # ğŸ”¥ SELECT FOR UPDATE
        
        if not quota:
            # åˆ›å»ºæ–°é…é¢è®°å½•
            quota = UserQuota(
                id=str(uuid.uuid4()),
                user_id=user_id,
                quota_date=today,
                generated_count=0,
                current_card_exists=False,
                max_daily_quota=2,
                version=1
            )
            self.db.add(quota)
            self.db.flush()  # è·å–IDä½†ä¸æäº¤äº‹åŠ¡
            
        return quota
```

#### **3.4 ç†”æ–­å’Œé™æµæœºåˆ¶**
```python
# ğŸ”¥ APIç†”æ–­å™¨è®¾è®¡
class CircuitBreaker:
    def __init__(self, failure_threshold: int = 5, recovery_timeout: int = 60):
        self.failure_threshold = failure_threshold
        self.recovery_timeout = recovery_timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "CLOSED"  # CLOSED, OPEN, HALF_OPEN
        
    async def call(self, func, *args, **kwargs):
        """ç†”æ–­å™¨åŒ…è£…çš„å‡½æ•°è°ƒç”¨"""
        if self.state == "OPEN":
            if time.time() - self.last_failure_time > self.recovery_timeout:
                self.state = "HALF_OPEN"
            else:
                raise ServiceUnavailableError("æœåŠ¡ç†”æ–­ä¸­ï¼Œè¯·ç¨åé‡è¯•")
                
        try:
            result = await func(*args, **kwargs)
            
            # è°ƒç”¨æˆåŠŸï¼Œé‡ç½®è®¡æ•°å™¨
            if self.state == "HALF_OPEN":
                self.state = "CLOSED"
                self.failure_count = 0
                
            return result
            
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = time.time()
            
            if self.failure_count >= self.failure_threshold:
                self.state = "OPEN"
                
            raise e

# ğŸ”¥ ç”¨æˆ·çº§åˆ«çš„APIé™æµå™¨
class UserRateLimiter:
    def __init__(self, redis_client):
        self.redis = redis_client
        
    async def check_rate_limit(self, user_id: str, action: str, limit: int, window: int) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ“ä½œé¢‘ç‡é™åˆ¶
        
        Args:
            user_id: ç”¨æˆ·ID
            action: æ“ä½œç±»å‹ (create_postcard, delete_postcard)
            limit: é™åˆ¶æ¬¡æ•°
            window: æ—¶é—´çª—å£(ç§’)
        """
        key = f"rate_limit:{user_id}:{action}"
        current_time = int(time.time())
        window_start = current_time - window
        
        # ä½¿ç”¨Redisæ»‘åŠ¨çª—å£ç®—æ³•
        pipe = self.redis.pipeline()
        pipe.zremrangebyscore(key, 0, window_start)  # æ¸…é™¤è¿‡æœŸè®°å½•
        pipe.zadd(key, {str(current_time): current_time})  # æ·»åŠ å½“å‰è¯·æ±‚
        pipe.zcount(key, window_start, current_time)  # ç»Ÿè®¡çª—å£å†…è¯·æ±‚æ•°
        pipe.expire(key, window)  # è®¾ç½®è¿‡æœŸæ—¶é—´
        
        results = await pipe.execute()
        current_count = results[2]
        
        if current_count > limit:
            logger.warning(f"ç”¨æˆ· {user_id} è§¦å‘é™æµ: {action} - {current_count}/{limit}")
            return False
            
        return True
```

---

## ğŸš¦ ç¬¬å››é˜¶æ®µï¼šAPIå®‰å…¨å¢å¼ºè®¾è®¡

### **ğŸ›¡ï¸ å¤šå±‚APIå®‰å…¨é˜²æŠ¤ä½“ç³»**

#### **4.1 è¯·æ±‚éªŒè¯å’Œæ¸…æ´—**
```python
# ğŸ”¥ è¯·æ±‚éªŒè¯ä¸­é—´ä»¶
class RequestValidationMiddleware:
    def __init__(self, app):
        self.app = app
        self.max_request_size = 10 * 1024 * 1024  # 10MB
        self.allowed_content_types = {
            "application/json",
            "application/x-www-form-urlencoded",
            "multipart/form-data"
        }
        
    async def __call__(self, scope, receive, send):
        request = Request(scope, receive)
        
        try:
            # ğŸ”¥ 1. æ£€æŸ¥è¯·æ±‚å¤§å°
            content_length = request.headers.get("content-length")
            if content_length and int(content_length) > self.max_request_size:
                return await self._error_response(
                    scope, receive, send,
                    413, "è¯·æ±‚ä½“è¿‡å¤§"
                )
                
            # ğŸ”¥ 2. éªŒè¯Content-Type
            content_type = request.headers.get("content-type", "").split(";")[0]
            if request.method in ["POST", "PUT", "PATCH"]:
                if content_type not in self.allowed_content_types:
                    return await self._error_response(
                        scope, receive, send,
                        415, "ä¸æ”¯æŒçš„å†…å®¹ç±»å‹"
                    )
                    
            # ğŸ”¥ 3. SQLæ³¨å…¥æ£€æµ‹
            if await self._has_sql_injection(request):
                await SecurityAuditService.log_security_event(
                    event_type="SQL_INJECTION_ATTEMPT",
                    request=request,
                    severity="HIGH"
                )
                return await self._error_response(
                    scope, receive, send,
                    400, "è¯·æ±‚åŒ…å«éæ³•å­—ç¬¦"
                )
                
            # ğŸ”¥ 4. XSSæ£€æµ‹
            if await self._has_xss_attempt(request):
                await SecurityAuditService.log_security_event(
                    event_type="XSS_ATTEMPT",
                    request=request,
                    severity="HIGH"
                )
                return await self._error_response(
                    scope, receive, send,
                    400, "è¯·æ±‚åŒ…å«æ¶æ„è„šæœ¬"
                )
                
            return await self.app(scope, receive, send)
            
        except Exception as e:
            logger.error(f"è¯·æ±‚éªŒè¯å¤±è´¥: {str(e)}")
            return await self._error_response(
                scope, receive, send,
                500, "å†…éƒ¨æœåŠ¡å™¨é”™è¯¯"
            )

# ğŸ”¥ è¾“å…¥æ¸…æ´—å’ŒéªŒè¯
class InputSanitizer:
    @staticmethod
    def sanitize_user_input(text: str, max_length: int = 1000) -> str:
        """æ¸…æ´—ç”¨æˆ·è¾“å…¥"""
        if not text:
            return ""
            
        # ç§»é™¤æ§åˆ¶å­—ç¬¦
        text = re.sub(r'[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]', '', text)
        
        # é™åˆ¶é•¿åº¦
        text = text[:max_length]
        
        # HTMLè½¬ä¹‰
        text = html.escape(text)
        
        # ç§»é™¤æ½œåœ¨çš„SQLæ³¨å…¥å­—ç¬¦
        dangerous_patterns = [
            r"(union|select|insert|update|delete|drop|exec|execute)\s",
            r"[;'\"\\]",
            r"--",
            r"/\*.*?\*/"
        ]
        
        for pattern in dangerous_patterns:
            text = re.sub(pattern, "", text, flags=re.IGNORECASE)
            
        return text.strip()
        
    @staticmethod
    def validate_uuid(uuid_string: str) -> bool:
        """éªŒè¯UUIDæ ¼å¼"""
        try:
            uuid.UUID(uuid_string)
            return True
        except ValueError:
            return False
```

#### **4.2 å¤šç»´åº¦é™æµç³»ç»Ÿ**
```python
# ğŸ”¥ å¤šç»´åº¦é™æµè£…é¥°å™¨
def rate_limit(
    user_limit: int = 100,      # ç”¨æˆ·ç»´åº¦é™æµ
    ip_limit: int = 1000,       # IPç»´åº¦é™æµ
    global_limit: int = 10000,  # å…¨å±€é™æµ
    window: int = 3600          # æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
):
    def decorator(func):
        @functools.wraps(func)
        async def wrapper(*args, **kwargs):
            request = args[0] if args else kwargs.get('request')
            
            # è·å–é™æµæœåŠ¡
            limiter = RateLimitService(get_redis_client())
            
            # è·å–å®¢æˆ·ç«¯æ ‡è¯†
            client_ip = request.client.host
            user_id = getattr(request.state, 'user', {}).get('user_id')
            
            # ğŸ”¥ 1. å…¨å±€é™æµæ£€æŸ¥
            if not await limiter.check_global_limit("api_calls", global_limit, window):
                raise HTTPException(
                    status_code=429,
                    detail="ç³»ç»Ÿç¹å¿™ï¼Œè¯·ç¨åé‡è¯•",
                    headers={"Retry-After": str(window)}
                )
                
            # ğŸ”¥ 2. IPç»´åº¦é™æµ
            if not await limiter.check_ip_limit(client_ip, ip_limit, window):
                # è®°å½•å¯ç–‘IP
                await SecurityAuditService.log_security_event(
                    event_type="IP_RATE_LIMIT_EXCEEDED",
                    client_ip=client_ip,
                    severity="MEDIUM"
                )
                raise HTTPException(
                    status_code=429,
                    detail="è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•",
                    headers={"Retry-After": str(window)}
                )
                
            # ğŸ”¥ 3. ç”¨æˆ·ç»´åº¦é™æµ
            if user_id and not await limiter.check_user_limit(user_id, user_limit, window):
                raise HTTPException(
                    status_code=429,
                    detail="æ“ä½œè¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•",
                    headers={"Retry-After": str(window)}
                )
                
            return await func(*args, **kwargs)
        return wrapper
    return decorator

# ğŸ”¥ æ™ºèƒ½é™æµæœåŠ¡
class RateLimitService:
    def __init__(self, redis_client):
        self.redis = redis_client
        
    async def check_user_limit(self, user_id: str, limit: int, window: int) -> bool:
        """ç”¨æˆ·ç»´åº¦é™æµ"""
        return await self._sliding_window_check(f"user:{user_id}", limit, window)
        
    async def check_ip_limit(self, ip: str, limit: int, window: int) -> bool:
        """IPç»´åº¦é™æµ"""
        return await self._sliding_window_check(f"ip:{ip}", limit, window)
        
    async def check_global_limit(self, api: str, limit: int, window: int) -> bool:
        """å…¨å±€APIé™æµ"""
        return await self._sliding_window_check(f"global:{api}", limit, window)
        
    async def _sliding_window_check(self, key: str, limit: int, window: int) -> bool:
        """æ»‘åŠ¨çª—å£é™æµå®ç°"""
        current_time = int(time.time())
        window_start = current_time - window
        
        # Redis Luaè„šæœ¬å®ç°åŸå­æ“ä½œ
        lua_script = """
        local key = KEYS[1]
        local window_start = ARGV[1]
        local current_time = ARGV[2]
        local limit = ARGV[3]
        local window = ARGV[4]
        
        -- æ¸…é™¤è¿‡æœŸè®°å½•
        redis.call('ZREMRANGEBYSCORE', key, 0, window_start)
        
        -- è·å–å½“å‰çª—å£å†…çš„è¯·æ±‚æ•°
        local current_count = redis.call('ZCOUNT', key, window_start, current_time)
        
        if current_count < tonumber(limit) then
            -- æ·»åŠ å½“å‰è¯·æ±‚
            redis.call('ZADD', key, current_time, current_time)
            redis.call('EXPIRE', key, window)
            return 1
        else
            return 0
        end
        """
        
        result = await self.redis.eval(
            lua_script, 1, key,
            window_start, current_time, limit, window
        )
        
        return bool(result)
```

#### **4.3 APIå®‰å…¨ç›‘æ§**
```python
# ğŸ”¥ APIå®‰å…¨ç›‘æ§æœåŠ¡
class APISecurityMonitor:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.suspicious_patterns = {
            "brute_force": {
                "threshold": 10,    # 10æ¬¡å¤±è´¥
                "window": 300,      # 5åˆ†é’Ÿ
                "block_duration": 3600  # å°ç¦1å°æ—¶
            },
            "unusual_access": {
                "threshold": 100,   # å¼‚å¸¸è®¿é—®é¢‘ç‡
                "window": 60,       # 1åˆ†é’Ÿ
                "block_duration": 300
            }
        }
        
    async def track_failed_auth(self, identifier: str, ip: str):
        """è¿½è¸ªè®¤è¯å¤±è´¥"""
        key = f"auth_failed:{identifier}:{ip}"
        pattern = self.suspicious_patterns["brute_force"]
        
        # å¢åŠ å¤±è´¥è®¡æ•°
        pipe = self.redis.pipeline()
        pipe.incr(key)
        pipe.expire(key, pattern["window"])
        results = await pipe.execute()
        
        failed_count = results[0]
        
        if failed_count >= pattern["threshold"]:
            # è§¦å‘å®‰å…¨äº‹ä»¶
            await self._trigger_security_event(
                event_type="BRUTE_FORCE_DETECTED",
                identifier=identifier,
                ip=ip,
                details={"failed_attempts": failed_count}
            )
            
            # ä¸´æ—¶å°ç¦
            await self._temporary_block(identifier, ip, pattern["block_duration"])
            
    async def check_unusual_access_pattern(self, user_id: str, ip: str, endpoint: str):
        """æ£€æµ‹å¼‚å¸¸è®¿é—®æ¨¡å¼"""
        # æ£€æŸ¥ç”¨æˆ·ä»å¤šä¸ªIPè®¿é—®
        user_ips_key = f"user_ips:{user_id}"
        await self.redis.sadd(user_ips_key, ip)
        await self.redis.expire(user_ips_key, 3600)  # 1å°æ—¶è¿‡æœŸ
        
        ip_count = await self.redis.scard(user_ips_key)
        
        if ip_count > 5:  # 1å°æ—¶å†…è¶…è¿‡5ä¸ªIP
            await self._trigger_security_event(
                event_type="MULTIPLE_IP_ACCESS",
                user_id=user_id,
                ip=ip,
                details={"ip_count": ip_count}
            )
            
        # æ£€æŸ¥å•ä¸ªIPè®¿é—®å¤šä¸ªç”¨æˆ·
        ip_users_key = f"ip_users:{ip}"
        await self.redis.sadd(ip_users_key, user_id)
        await self.redis.expire(ip_users_key, 3600)
        
        user_count = await self.redis.scard(ip_users_key)
        
        if user_count > 10:  # å•IPè®¿é—®è¶…è¿‡10ä¸ªç”¨æˆ·
            await self._trigger_security_event(
                event_type="MULTIPLE_USER_ACCESS",
                ip=ip,
                details={"user_count": user_count}
            )
```

---

## ğŸ“Š ç¬¬äº”é˜¶æ®µï¼šå®¡è®¡ç›‘æ§ä½“ç³»è®¾è®¡

### **ğŸ“‹ å…¨æ–¹ä½å®¡è®¡ç›‘æ§ç³»ç»Ÿ**

#### **5.1 ç»“æ„åŒ–å®¡è®¡æ—¥å¿—è®¾è®¡**
```sql
-- ğŸ”¥ å®¡è®¡æ—¥å¿—è¡¨è®¾è®¡
CREATE TABLE audit_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES users(id),
    session_id VARCHAR(255),
    action VARCHAR(100) NOT NULL,           -- LOGIN, POSTCARD_CREATE, POSTCARD_DELETE
    resource_type VARCHAR(50),              -- postcard, quota, user
    resource_id VARCHAR(255),
    old_values JSONB,                       -- æ“ä½œå‰çš„æ•°æ®
    new_values JSONB,                       -- æ“ä½œåçš„æ•°æ®
    client_ip INET NOT NULL,
    user_agent TEXT,
    request_id VARCHAR(255),
    api_endpoint VARCHAR(255),
    http_method VARCHAR(10),
    response_code INTEGER,
    execution_time_ms INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    
    -- ç´¢å¼•ä¼˜åŒ–æŸ¥è¯¢
    INDEX idx_audit_user_action (user_id, action, created_at),
    INDEX idx_audit_resource (resource_type, resource_id),
    INDEX idx_audit_security (client_ip, action, created_at)
);

-- ğŸ”¥ å®‰å…¨äº‹ä»¶è¡¨
CREATE TABLE security_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_type VARCHAR(100) NOT NULL,      -- BRUTE_FORCE, SQL_INJECTION, UNUSUAL_ACCESS
    severity VARCHAR(20) NOT NULL,         -- LOW, MEDIUM, HIGH, CRITICAL
    user_id UUID REFERENCES users(id),
    client_ip INET,
    details JSONB NOT NULL,
    resolved_at TIMESTAMP NULL,
    resolved_by UUID REFERENCES users(id),
    created_at TIMESTAMP DEFAULT NOW(),
    
    INDEX idx_security_severity_time (severity, created_at),
    INDEX idx_security_ip_type (client_ip, event_type)
);
```

#### **5.2 æ™ºèƒ½å®¡è®¡æœåŠ¡**
```python
# ğŸ”¥ ç»¼åˆå®¡è®¡æœåŠ¡
class AuditService:
    def __init__(self, db: Session, redis_client):
        self.db = db
        self.redis = redis_client
        self.sensitive_fields = {"password", "token", "secret", "key"}
        
    async def log_user_action(
        self, 
        user_id: str,
        action: str,
        resource_type: str = None,
        resource_id: str = None,
        old_values: dict = None,
        new_values: dict = None,
        request_context: dict = None
    ):
        """è®°å½•ç”¨æˆ·æ“ä½œå®¡è®¡æ—¥å¿—"""
        try:
            # æ¸…ç†æ•æ„Ÿä¿¡æ¯
            clean_old = self._sanitize_sensitive_data(old_values)
            clean_new = self._sanitize_sensitive_data(new_values)
            
            audit_log = AuditLog(
                user_id=user_id,
                action=action,
                resource_type=resource_type,
                resource_id=resource_id,
                old_values=clean_old,
                new_values=clean_new,
                client_ip=request_context.get("client_ip"),
                user_agent=request_context.get("user_agent"),
                request_id=request_context.get("request_id"),
                api_endpoint=request_context.get("api_endpoint"),
                http_method=request_context.get("http_method"),
                response_code=request_context.get("response_code"),
                execution_time_ms=request_context.get("execution_time_ms")
            )
            
            self.db.add(audit_log)
            self.db.commit()
            
            # ğŸ”¥ å®æ—¶åˆ†æå¼‚å¸¸æ¨¡å¼
            await self._analyze_user_behavior(user_id, action, request_context)
            
        except Exception as e:
            logger.error(f"å®¡è®¡æ—¥å¿—è®°å½•å¤±è´¥: {str(e)}")
            
    async def log_security_event(
        self,
        event_type: str,
        severity: str,
        user_id: str = None,
        client_ip: str = None,
        details: dict = None
    ):
        """è®°å½•å®‰å…¨äº‹ä»¶"""
        try:
            security_event = SecurityEvent(
                event_type=event_type,
                severity=severity,
                user_id=user_id,
                client_ip=client_ip,
                details=details or {}
            )
            
            self.db.add(security_event)
            self.db.commit()
            
            # ğŸ”¥ é«˜å±äº‹ä»¶å®æ—¶å‘Šè­¦
            if severity in ["HIGH", "CRITICAL"]:
                await self._trigger_security_alert(security_event)
                
        except Exception as e:
            logger.error(f"å®‰å…¨äº‹ä»¶è®°å½•å¤±è´¥: {str(e)}")
            
    async def _analyze_user_behavior(self, user_id: str, action: str, context: dict):
        """åˆ†æç”¨æˆ·è¡Œä¸ºæ¨¡å¼"""
        # æ£€æŸ¥å¼‚å¸¸æ“ä½œé¢‘ç‡
        if action in ["POSTCARD_CREATE", "POSTCARD_DELETE"]:
            key = f"user_action:{user_id}:{action}"
            count = await self.redis.incr(key)
            await self.redis.expire(key, 3600)  # 1å°æ—¶çª—å£
            
            # å¼‚å¸¸é«˜é¢‘æ“ä½œæ£€æµ‹
            thresholds = {
                "POSTCARD_CREATE": 20,    # 1å°æ—¶å†…åˆ›å»ºè¶…è¿‡20æ¬¡
                "POSTCARD_DELETE": 50     # 1å°æ—¶å†…åˆ é™¤è¶…è¿‡50æ¬¡
            }
            
            if count > thresholds.get(action, 100):
                await self.log_security_event(
                    event_type="UNUSUAL_USER_ACTIVITY",
                    severity="MEDIUM",
                    user_id=user_id,
                    client_ip=context.get("client_ip"),
                    details={
                        "action": action,
                        "count_1h": count,
                        "threshold": thresholds[action]
                    }
                )
```

#### **5.3 å®æ—¶ç›‘æ§å’Œå‘Šè­¦**
```python
# ğŸ”¥ å®æ—¶ç›‘æ§ç³»ç»Ÿ
class SecurityMonitoringService:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.alert_channels = {
            "email": EmailAlertChannel(),
            "slack": SlackAlertChannel(),
            "webhook": WebhookAlertChannel()
        }
        
    async def start_monitoring(self):
        """å¯åŠ¨å®æ—¶ç›‘æ§"""
        tasks = [
            self._monitor_failed_logins(),
            self._monitor_quota_anomalies(),
            self._monitor_api_abuse(),
            self._monitor_data_integrity()
        ]
        
        await asyncio.gather(*tasks)
        
    async def _monitor_failed_logins(self):
        """ç›‘æ§ç™»å½•å¤±è´¥æ¨¡å¼"""
        while True:
            try:
                # æ£€æŸ¥æš´åŠ›ç ´è§£æ”»å‡»
                failed_login_pattern = await self._detect_brute_force_pattern()
                if failed_login_pattern:
                    await self._send_alert(
                        level="HIGH",
                        title="ç–‘ä¼¼æš´åŠ›ç ´è§£æ”»å‡»",
                        message=f"æ£€æµ‹åˆ°æ¥è‡ª {failed_login_pattern['ip']} çš„æš´åŠ›ç ´è§£å°è¯•",
                        details=failed_login_pattern
                    )
                    
                await asyncio.sleep(60)  # æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
                
            except Exception as e:
                logger.error(f"ç™»å½•ç›‘æ§å¤±è´¥: {str(e)}")
                await asyncio.sleep(60)
                
    async def _monitor_quota_anomalies(self):
        """ç›‘æ§é…é¢å¼‚å¸¸"""
        while True:
            try:
                # æ£€æŸ¥é…é¢ç»•è¿‡å°è¯•
                anomalies = await self._detect_quota_bypass_attempts()
                
                for anomaly in anomalies:
                    await self._send_alert(
                        level="HIGH",
                        title="é…é¢ç»•è¿‡å¼‚å¸¸",
                        message=f"ç”¨æˆ· {anomaly['user_id']} å¯èƒ½å°è¯•ç»•è¿‡é…é¢é™åˆ¶",
                        details=anomaly
                    )
                    
                await asyncio.sleep(300)  # æ¯5åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
                
            except Exception as e:
                logger.error(f"é…é¢ç›‘æ§å¤±è´¥: {str(e)}")
                await asyncio.sleep(300)
                
    async def _detect_quota_bypass_attempts(self) -> List[dict]:
        """æ£€æµ‹é…é¢ç»•è¿‡å°è¯•"""
        # æŸ¥è¯¢1å°æ—¶å†…åˆ›å»ºä»»åŠ¡æ•°é‡å¼‚å¸¸çš„ç”¨æˆ·
        query = """
        SELECT 
            user_id,
            COUNT(*) as task_count,
            COUNT(DISTINCT client_ip) as ip_count,
            MAX(q.generated_count) as quota_count
        FROM audit_logs a
        LEFT JOIN user_quotas q ON a.user_id = q.user_id 
        WHERE 
            a.action = 'POSTCARD_CREATE' 
            AND a.created_at > NOW() - INTERVAL '1 hour'
        GROUP BY user_id
        HAVING 
            COUNT(*) > 5  -- è¶…è¿‡æ­£å¸¸é…é¢
            OR COUNT(DISTINCT client_ip) > 3  -- å¤šIPæ“ä½œ
        """
        
        result = await self.db.execute(text(query))
        
        anomalies = []
        for row in result:
            if row.task_count > 2:  # è¶…è¿‡æ¯æ—¥é…é¢
                anomalies.append({
                    "user_id": row.user_id,
                    "task_count_1h": row.task_count,
                    "ip_count": row.ip_count,
                    "quota_count": row.quota_count,
                    "severity": "HIGH"
                })
                
        return anomalies
```

#### **5.4 åˆè§„æ€§æŠ¥å‘Šç”Ÿæˆ**
```python
# ğŸ”¥ åˆè§„æ€§æŠ¥å‘ŠæœåŠ¡
class ComplianceReportService:
    def __init__(self, db: Session):
        self.db = db
        
    async def generate_security_report(self, start_date: date, end_date: date) -> dict:
        """ç”Ÿæˆå®‰å…¨åˆè§„æŠ¥å‘Š"""
        return {
            "period": {"start": start_date, "end": end_date},
            "summary": await self._get_security_summary(start_date, end_date),
            "user_activities": await self._get_user_activity_stats(start_date, end_date),
            "security_events": await self._get_security_events_stats(start_date, end_date),
            "access_patterns": await self._get_access_pattern_analysis(start_date, end_date),
            "quota_compliance": await self._get_quota_compliance_stats(start_date, end_date),
            "recommendations": await self._generate_security_recommendations(start_date, end_date)
        }
        
    async def _get_security_summary(self, start_date: date, end_date: date) -> dict:
        """å®‰å…¨äº‹ä»¶æ€»è§ˆ"""
        query = """
        SELECT 
            event_type,
            severity,
            COUNT(*) as count,
            COUNT(DISTINCT client_ip) as unique_ips,
            COUNT(DISTINCT user_id) as affected_users
        FROM security_events 
        WHERE created_at BETWEEN :start_date AND :end_date
        GROUP BY event_type, severity
        ORDER BY severity DESC, count DESC
        """
        
        result = await self.db.execute(text(query), {
            "start_date": start_date,
            "end_date": end_date
        })
        
        events_by_type = {}
        total_events = 0
        critical_events = 0
        
        for row in result:
            events_by_type[row.event_type] = {
                "count": row.count,
                "severity": row.severity,
                "unique_ips": row.unique_ips,
                "affected_users": row.affected_users
            }
            total_events += row.count
            if row.severity == "CRITICAL":
                critical_events += row.count
                
        return {
            "total_events": total_events,
            "critical_events": critical_events,
            "events_by_type": events_by_type,
            "security_level": "HIGH" if critical_events == 0 else "MEDIUM" if critical_events < 5 else "LOW"
        }
```

---

## ğŸš€ å®æ–½è·¯çº¿å›¾ä¸æˆæœ¬è¯„ä¼°

### **ğŸ“… åˆ†é˜¶æ®µå®æ–½è®¡åˆ’**

#### **ğŸ¯ Phase 1: ç´§æ€¥å®‰å…¨ä¿®å¤ (1-2å‘¨)**
**ä¼˜å…ˆçº§**: ğŸš¨ CRITICAL
- **èº«ä»½éªŒè¯ç³»ç»Ÿ**: JWT Token + ä¸­é—´ä»¶
- **åŸºç¡€æƒé™æ§åˆ¶**: ç”¨æˆ·èµ„æºæ‰€æœ‰æƒéªŒè¯
- **å¹¶å‘å®‰å…¨**: åˆ†å¸ƒå¼é” + äº‹åŠ¡æ§åˆ¶
- **é¢„æœŸæ•ˆæœ**: æ¶ˆé™¤90%çš„å®‰å…¨æ¼æ´

#### **ğŸ›¡ï¸ Phase 2: å…¨é¢é˜²æŠ¤å‡çº§ (2-3å‘¨)**
**ä¼˜å…ˆçº§**: ğŸ”¥ HIGH
- **å®Œæ•´RBACç³»ç»Ÿ**: è§’è‰²æƒé™ç®¡ç†
- **å¤šç»´åº¦é™æµ**: ç”¨æˆ·/IP/å…¨å±€é™æµ
- **è¾“å…¥éªŒè¯**: SQLæ³¨å…¥/XSSé˜²æŠ¤
- **é¢„æœŸæ•ˆæœ**: å»ºç«‹å®Œæ•´å®‰å…¨é˜²æŠ¤ä½“ç³»

#### **ğŸ“Š Phase 3: ç›‘æ§å®¡è®¡å®Œå–„ (1-2å‘¨)**
**ä¼˜å…ˆçº§**: âš ï¸ MEDIUM
- **å®¡è®¡æ—¥å¿—ç³»ç»Ÿ**: å®Œæ•´æ“ä½œè®°å½•
- **å®æ—¶ç›‘æ§**: å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
- **å®‰å…¨æŠ¥å‘Š**: åˆè§„æ€§åˆ†æ
- **é¢„æœŸæ•ˆæœ**: å»ºç«‹ä¸»åŠ¨å®‰å…¨è¿è¥èƒ½åŠ›

### **ğŸ’° èµ„æºæŠ•å…¥è¯„ä¼°**

#### **å¼€å‘æˆæœ¬**
- **Phase 1**: 40-60å·¥æ—¶ (ç´§æ€¥ä¿®å¤)
- **Phase 2**: 60-80å·¥æ—¶ (å…¨é¢å‡çº§)  
- **Phase 3**: 30-40å·¥æ—¶ (ç›‘æ§å®Œå–„)
- **æ€»è®¡**: 130-180å·¥æ—¶

#### **åŸºç¡€è®¾æ–½æˆæœ¬**
- **Redisé›†ç¾¤**: ç”¨äºåˆ†å¸ƒå¼é”å’Œé™æµ (~$50/æœˆ)
- **æ—¥å¿—å­˜å‚¨**: ELK Stackæˆ–äº‘æœåŠ¡ (~$100/æœˆ)
- **ç›‘æ§å‘Šè­¦**: å‘Šè­¦é€šçŸ¥æœåŠ¡ (~$20/æœˆ)
- **SSLè¯ä¹¦**: HTTPSå®‰å…¨ä¼ è¾“ (~$10/æœˆ)

### **ğŸ¯ é¢„æœŸå®‰å…¨æ”¶ç›Š**

#### **é£é™©é™ä½**
- âœ… **ç”¨æˆ·æ•°æ®æ³„éœ²é£é™©**: ä»HIGHé™è‡³LOW
- âœ… **æ¶æ„æ”»å‡»é£é™©**: ä»CRITICALé™è‡³LOW
- âœ… **æœåŠ¡æ»¥ç”¨é£é™©**: ä»HIGHé™è‡³MINIMAL
- âœ… **åˆè§„æ€§é£é™©**: ä»MEDIUMé™è‡³MINIMAL

#### **ä¸šåŠ¡ä»·å€¼æå‡**
- ğŸš€ **ç”¨æˆ·ä¿¡ä»»åº¦**: æå‡å®‰å…¨æ„ŸçŸ¥ï¼Œå¢åŠ ç”¨æˆ·ç²˜æ€§
- ğŸ“ˆ **æœåŠ¡ç¨³å®šæ€§**: é˜²æ­¢æ¶æ„æ”»å‡»å¯¼è‡´çš„æœåŠ¡ä¸­æ–­
- ğŸ’¼ **å•†ä¸šåŒ–å°±ç»ª**: æ»¡è¶³ä¼ä¸šçº§å®‰å…¨è¦æ±‚
- ğŸ›¡ï¸ **å“ç‰Œä¿æŠ¤**: é¿å…å®‰å…¨äº‹æ•…å¯¼è‡´çš„å£°èª‰æŸå¤±

---

## ğŸ“‹ å®æ–½å»ºè®®ä¸æ³¨æ„äº‹é¡¹

### **ğŸš¦ å®æ–½ä¼˜å…ˆçº§å»ºè®®**

1. **ç«‹å³å®æ–½ (æœ¬å‘¨å†…)**:
   - JWTèº«ä»½éªŒè¯ä¸­é—´ä»¶
   - åˆ›å»º/åˆ é™¤APIçš„ç”¨æˆ·éªŒè¯
   - å¹¶å‘å®‰å…¨çš„é…é¢æ§åˆ¶

2. **çŸ­æœŸå®æ–½ (2å‘¨å†…)**:
   - å®Œæ•´çš„æƒé™éªŒè¯ç³»ç»Ÿ
   - APIé™æµå’Œè¾“å…¥éªŒè¯
   - åŸºç¡€å®¡è®¡æ—¥å¿—

3. **ä¸­æœŸå®Œå–„ (1ä¸ªæœˆå†…)**:
   - å®æ—¶å®‰å…¨ç›‘æ§
   - å¼‚å¸¸è¡Œä¸ºæ£€æµ‹
   - å®‰å…¨æŠ¥å‘Šç”Ÿæˆ

### **âš ï¸ é£é™©æ§åˆ¶æªæ–½**

1. **æ¸è¿›å¼éƒ¨ç½²**: 
   - ç°åº¦å‘å¸ƒï¼Œå…ˆåœ¨æµ‹è¯•ç¯å¢ƒéªŒè¯
   - ä¿ç•™å›æ»šæ–¹æ¡ˆï¼Œç¡®ä¿å¿«é€Ÿæ¢å¤

2. **å…¼å®¹æ€§ä¿è¯**:
   - å‰ç«¯Tokenè·å–å’Œå­˜å‚¨é€‚é…
   - APIå“åº”æ ¼å¼ä¿æŒä¸€è‡´æ€§

3. **æ€§èƒ½ç›‘æ§**:
   - ç›‘æ§è®¤è¯ä¸­é—´ä»¶æ€§èƒ½å½±å“
   - åˆ†å¸ƒå¼é”è¶…æ—¶æœºåˆ¶ä¼˜åŒ–

### **ğŸ‰ æ€»ç»“**

è¿™ä¸ªå®‰å…¨å‡çº§æ–¹æ¡ˆå°†AIæ˜ä¿¡ç‰‡ç³»ç»Ÿä»**å®‰å…¨æ¼æ´ç™¾å‡º**çš„çŠ¶æ€å‡çº§ä¸º**ä¼ä¸šçº§å®‰å…¨æ ‡å‡†**ï¼Œé€šè¿‡å¤šå±‚é˜²æŠ¤æœºåˆ¶ç¡®ä¿ï¼š

- **ğŸ” é›¶ä¿¡ä»»æ¶æ„**: æ‰€æœ‰æ“ä½œå¿…é¡»ç»è¿‡èº«ä»½éªŒè¯å’Œæƒé™éªŒè¯
- **âš¡ å¹¶å‘å®‰å…¨**: æ¶ˆé™¤ç«æ€æ¡ä»¶ï¼Œç¡®ä¿é…é¢ç³»ç»Ÿä¸¥æ ¼æ‰§è¡Œ
- **ğŸ›¡ï¸ æ·±åº¦é˜²å¾¡**: å¤šç»´åº¦é™æµã€è¾“å…¥éªŒè¯ã€å¼‚å¸¸æ£€æµ‹
- **ğŸ“Š å…¨é¢å®¡è®¡**: å®Œæ•´çš„æ“ä½œè®°å½•å’Œå®‰å…¨äº‹ä»¶è¿½æº¯

å®æ–½å®Œæˆåï¼Œç³»ç»Ÿå°†å…·å¤‡**ç”Ÿäº§çº§å®‰å…¨èƒ½åŠ›**ï¼Œä¸ºç”¨æˆ·æä¾›å®‰å…¨å¯é çš„AIæ˜ä¿¡ç‰‡ç”ŸæˆæœåŠ¡ï¼

---

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [ç³»ç»Ÿæ¶æ„æ€»è§ˆ](./00-system-architecture.md)
- [APIè§„èŒƒæ–‡æ¡£](./07-api-specification.md)
- [æ•°æ®åº“è®¾è®¡](./06-database-schema.md)
- [éƒ¨ç½²é…ç½®](./08-deployment-cicd.md)

---

> **æœ€åæ›´æ–°**: 2025-09-08  
> **çŠ¶æ€**: è®¾è®¡å®Œæˆï¼Œå¾…å®æ–½  
> **å®¡æ ¸**: å¾…æŠ€æœ¯è´Ÿè´£äººå®¡æ ¸